# API Deployment

## Django Best Practices

- Keep settings in environment variables.
- Write default values for production configuration (excluding secret keys and tokens).
- Don’t hardcode sensitive settings, and don’t put them in VCS.
- Split settings into groups: Django, third-party, project.
- Follow naming conventions for custom (project) settings.
____

settings.py file - separate settings file for each environment to keep all configurations in VCS (Version Control System) and share default settings between devs.

Create a settings package like this:
```
settings/
   ├── __init__.py
   ├── base.py
   ├── ci.py
   ├── local.py
   ├── staging.py
   ├── production.py
   └── qa.py
```

settings/local.py:
```
from .base import *


ALLOWED_HOSTS = ['localhost']
DEBUG = True
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'local_db',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```

To run with specific config, set an additional parameter:  
`$ python manage.py runserver --settings=settings.local`

Use environment variables to handle sensitive data:
```
import os


SECRET_KEY = os.environ['SECRET_KEY']
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ['DATABASE_NAME'],
        'HOST': os.environ['DATABASE_HOST'],
        'PORT': int(os.environ['DATABASE_PORT']),
    }
}
```

Handle KeyError exceptions and convert types manually (or use a third party library):
```
import os

from django.core.exceptions import ImproperlyConfigured


def get_env_value(env_variable):
    try:
      	return os.environ[env_variable]
    except KeyError:
        error_msg = 'Set the {} environment variable'.format(var_name)
        raise ImproperlyConfigured(error_msg)


SECRET_KEY = get_env_value('SECRET_KEY')
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': get_env_value('DATABASE_NAME'),
        'HOST': get_env_value('DATABASE_HOST'),
        'PORT': int(get_env_value('DATABASE_PORT')),
    }
}
```

### 12 factor recommendations
1. Codebase
2. Dependencies
3. Config
4. Backing services
5. Build, release, run
6. Processes
7. Port binding
8. Concurrency
9. Disposability
10. Dev/prod parity
11. Logs
12. Admin processes

### Django Environ
API for reading values from environment variables or text files, handle type conversion, etc.

```
import environ


root = environ.Path(__file__) - 3  # get root of the project
env = environ.Env()
environ.Env.read_env()  # reading .env file

SITE_ROOT = root()

DEBUG = env.bool('DEBUG', default=False)
TEMPLATE_DEBUG = DEBUG

DATABASES = {'default': env.db('DATABASE_URL')}

public_root = root.path('public/')
MEDIA_ROOT = public_root('media')
MEDIA_URL = env.str('MEDIA_URL', default='media/')
STATIC_ROOT = public_root('static')
STATIC_URL = env.str('STATIC_URL', default='static/')

SECRET_KEY = env.str('SECRET_KEY')

CACHES = {'default': env.cache('REDIS_CACHE_URL')}
```

.env file:
```
DEBUG=True
DATABASE_URL=postgres://user:password@db.example.com:5432/production_db?sslmode=require
REDIS_CACHE_URL=redis://user:password@cache.example.com:6379/1
SECRET_KEY=Some-Autogenerated-Secret-Key
```
_____

## SSH
SSH: Secure Shell
Remote administration protocol that allows users to control and modify their remote servers over the Internet. 

Most popular SSH client -> PuTTY

SSH command:  
`ssh {user}@{host}`
- ssh: open an encrypted Secure Shell Connection
- {user}: account you want to access
- {host}: computer you want to access (IP address or domain name)

Encryptions:
1. Symmetrical: secret key is used for both encryption and decryption of a message by both client and host. Often called shared key or shared secret encryption. Used to encrypt the entire commmunication during a SSH session. Two computers share public pieces of data and then manipulate it to independently calculate the secret key. The secret token is specific to each SSH session and generated prior to client authentication. 
2. Asymmetrical: uses 2 separate keys for encryption and decryption (public key and private key). Not used to encrypt the entire SSH session (only used during the key exchange algo of symmetric encryption). 
3. Hasing: never meant to be decrypted (impossible to reverse). Used to verify the authenticity of messages using Hash-based Message Authentication Codes (HMACs). 

How does it work?  
SSH makes use of a client-server model to allow for authentication of 2 remote systems and encryption of the data that passes between them. 

TCP port 22 (by default but can be changed)
- host(server) listens on port 22 for incoming connections
- secures connection by authenticating the client and opening the correct shell environment if verification is successful
- client begins SSH connection by initiating the TCP handshake with the server (ensuring a secured symmetric connection), verifying whether identity matches previous records, and inputting required user credentials
- to establish a connection, both the systems need to agree upon encryption standards and user must authenticate

Once established, two parties use Diffie-Hellman Key Exchange Algorithm to create symmetrical key. The algo allows client and server to arrive at shared encryption key. 

Authentication of User:  
User enters username and password. Credentials pass through the symmetrically encrypted tunnel. It's recommended to not use passwords for secure connections but instead use SSH Key Pairs, which are a set of asymmetric keys used to authenticate users without the need of entering password. 



